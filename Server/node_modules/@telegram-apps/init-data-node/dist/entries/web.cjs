"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const parse = require("./parse-BsMfaAL1.cjs");
const createHmac = async (data, key) => {
  const encoder = new TextEncoder();
  return Buffer.from(
    await crypto.subtle.sign(
      "HMAC",
      await crypto.subtle.importKey(
        "raw",
        typeof key === "string" ? encoder.encode(key) : key,
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign", "verify"]
      ),
      encoder.encode(data.toString())
    )
  );
};
function hashToken(token) {
  return parse.hashToken(token, createHmac);
}
function isValid(value, token, options) {
  return parse.isValid(value, token, validate, options);
}
function sign(data, key, authDate, options) {
  return parse.sign(data, key, authDate, signData, options);
}
function signData(data, key, options) {
  return parse.signData(data, key, createHmac, options);
}
function validate(value, token, options) {
  return Promise.resolve().then(() => parse.validate(value, token, signData, options));
}
exports.ERR_AUTH_DATE_INVALID = parse.ERR_AUTH_DATE_INVALID;
exports.ERR_EXPIRED = parse.ERR_EXPIRED;
exports.ERR_HASH_INVALID = parse.ERR_HASH_INVALID;
exports.ERR_PARSE = parse.h;
exports.ERR_SIGN_INVALID = parse.ERR_SIGN_INVALID;
exports.ERR_UNEXPECTED_VALUE = parse.S;
exports.TypedError = parse.d;
exports.initDataToSearchParams = parse.initDataToSearchParams;
exports.isErrorOfType = parse.F;
exports.parse = parse.parse;
exports.hashToken = hashToken;
exports.isValid = isValid;
exports.sign = sign;
exports.signData = signData;
exports.validate = validate;
//# sourceMappingURL=web.cjs.map
