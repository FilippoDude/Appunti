{"version":3,"file":"parse-BsMfaAL1.cjs","sources":["../../src/hashToken.ts","../../src/initDataToSearchParams.ts","../../src/sign.ts","../../src/signData.ts","../../../toolkit/dist/index.js","../../src/errors.ts","../../src/validate.ts","../../src/isValid.ts","../../../transformers/dist/index.js","../../src/parse.ts"],"sourcesContent":["import type { CreateHmacFn } from './types.js';\n\nexport function hashToken<H extends CreateHmacFn<any>>(\n  token: string | Buffer,\n  createHmac: H\n): ReturnType<H> {\n  return createHmac(token, 'WebAppData') as ReturnType<H>;\n}\n","import type { InitData, User } from '@telegram-apps/types';\n\n/**\n * Removes undefined properties from the object.\n * @param object - object to remove properties from.\n */\nfunction removeUndefined(object: Record<string, string | undefined>): Record<string, string> {\n  const result: Record<string, string> = {};\n  for (const key in object) {\n    const v = object[key];\n    if (v !== undefined) {\n      result[key] = v;\n    }\n  }\n  return result;\n}\n\n/**\n * Serializes user information.\n * @param user - user information.\n */\nfunction serializeUser(user: User | undefined): string | undefined {\n  return user\n    ? JSON.stringify({\n      added_to_attachment_menu: user.addedToAttachmentMenu,\n      allows_write_to_pm: user.allowsWriteToPm,\n      first_name: user.firstName,\n      id: user.id,\n      is_bot: user.isBot,\n      is_premium: user.isPremium,\n      language_code: user.languageCode,\n      last_name: user.lastName,\n      photo_url: user.photoUrl,\n      username: user.username,\n    })\n    : undefined;\n}\n\nexport function initDataToSearchParams({\n  chat,\n  receiver,\n  user,\n  ...data\n}: Partial<InitData>): URLSearchParams {\n  return new URLSearchParams(\n    removeUndefined({\n      auth_date: data.authDate\n        ? ((+data.authDate / 1000) | 0).toString()\n        : undefined,\n      can_send_after: data.canSendAfter?.toString(),\n      chat: chat\n        ? JSON.stringify({\n          id: chat.id,\n          type: chat.type,\n          title: chat.title,\n          photo_url: chat.type,\n          username: chat.username,\n        })\n        : undefined,\n      chat_instance: data.chatInstance,\n      chat_type: data.chatType || undefined,\n      hash: data.hash,\n      query_id: data.queryId,\n      receiver: serializeUser(receiver),\n      start_param: data.startParam || undefined,\n      user: serializeUser(user),\n    }),\n  );\n}","import { initDataToSearchParams } from './initDataToSearchParams.js';\n\nimport type { SharedOptions, SignData, SignDataAsyncFn, SignDataSyncFn, Text } from './types.js';\n\nexport type SignOptions = SharedOptions;\n\n/**\n * Signs specified init data.\n * @param data - init data to sign.\n * @param authDate - date, when this init data should be signed.\n * @param key - private key.\n * @param signData - function signing data.\n * @param options - additional options.\n * @returns Signed init data presented as query parameters.\n */\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataSyncFn,\n  options?: SignOptions,\n): string;\n\n/**\n * Signs specified init data.\n * @param data - init data to sign.\n * @param authDate - date, when this init data should be signed.\n * @param key - private key.\n * @param signData - function signing data.\n * @param options - additional options.\n * @returns Signed init data presented as query parameters.\n */\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataAsyncFn,\n  options?: SignOptions,\n): Promise<string>;\n\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataSyncFn | SignDataAsyncFn,\n  options?: SignOptions,\n): string | Promise<string> {\n  // Create search parameters, which will be signed further.\n  const sp = initDataToSearchParams({\n    ...data,\n    authDate,\n  });\n\n  // Convert search params to pairs and sort the final array.\n  const pairs = [...sp.entries()]\n    .map(([name, value]) => `${name}=${value}`)\n    .sort();\n\n  // Compute sign, append it to the params and return.\n  function processSign(s: string): string {\n    sp.append('hash', s);\n    return sp.toString();\n  }\n\n  const sign = signData(pairs.join('\\n'), key, options);\n  return typeof sign === 'string' ? processSign(sign) : sign.then(processSign);\n}\n","import { hashToken } from './hashToken.js';\nimport type { CreateHmacFn, SharedOptions, Text } from './types.js';\n\nexport type SignDataOptions = SharedOptions;\n\n/**\n * Signs specified data with the passed token.\n * @param data - data to sign.\n * @param key - private key.\n * @param createHmac - function to create HMAC-SHA256.\n * @param options - additional method options.\n * @returns Data sign.\n */\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<false>,\n  options?: SignDataOptions,\n): string;\n\n/**\n * Signs specified data with the passed token.\n * @param data - data to sign.\n * @param key - private key.\n * @param createHmac - function to create HMAC-SHA256.\n * @param options - additional method options.\n * @returns Data sign.\n */\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<true>,\n  options?: SignDataOptions,\n): Promise<string>;\n\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<boolean>,\n  options: SignDataOptions = {},\n): string | Promise<string> {\n  const keyHmac = options.tokenHashed ? key : hashToken(key, createHmac);\n  if (keyHmac instanceof Promise) {\n    return keyHmac\n      .then(v => createHmac(data, v))\n      .then(v => v.toString('hex'));\n  }\n\n  const hmac = createHmac(data, typeof keyHmac === 'string'\n    ? Buffer.from(keyHmac, 'hex')\n    : keyHmac);\n  return hmac instanceof Promise\n    ? hmac.then(v => v.toString('hex'))\n    : hmac.toString('hex');\n}\n","var k = Object.defineProperty;\nvar I = (r, e, t) => e in r ? k(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar E = (r, e, t) => I(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass d extends Error {\n  constructor(e, t, n) {\n    super(\n      typeof t == \"object\" ? t.message : t || e,\n      {\n        cause: typeof t == \"object\" ? t.cause : n\n      }\n    ), this.type = e, Object.setPrototypeOf(this, d.prototype);\n  }\n}\nfunction x(r, e, t) {\n  return r.addEventListener(e, t), () => r.removeEventListener(e, t);\n}\nfunction _(...r) {\n  const e = r.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\nfunction F(r, e) {\n  return r instanceof d && r.type === e;\n}\nfunction m(r) {\n  return (e) => F(e, r);\n}\nconst R = \"ERR_ABORTED\", $ = \"ERR_CANCELED\", S = \"ERR_TIMED_OUT\";\nfunction C(r) {\n  return new d(R, { cause: r });\n}\nconst U = m(S), V = m(R), B = m($);\nfunction T(r, e) {\n  return r.reject = e.reject, r;\n}\nclass i extends Promise {\n  constructor(t, n) {\n    let o, s;\n    typeof t == \"function\" ? (o = t, s = n) : s = t;\n    let u, c;\n    super((a, h) => {\n      s || (s = {});\n      const { abortSignal: l } = s;\n      if (l && l.aborted)\n        return h(C(l.reason));\n      const [y, A] = _(), b = (f) => (...L) => (A(), f(...L)), w = new AbortController(), { signal: D } = w;\n      c = b((f) => {\n        w.abort(f), h(f);\n      }), u = b(a), l && y(\n        x(l, \"abort\", () => {\n          c(C(l.reason));\n        })\n      );\n      const { timeout: g } = s;\n      if (g) {\n        const f = setTimeout(() => {\n          c(new d(S, `Timeout reached: ${g}ms`));\n        }, g);\n        y(() => {\n          clearTimeout(f);\n        });\n      }\n      o && o(u, c, D);\n    });\n    /**\n     * Rejects the promise.\n     */\n    E(this, \"reject\");\n    this.reject = c;\n  }\n  /**\n   * Creates a new BetterPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn(t, n) {\n    return new i((o, s, u) => {\n      try {\n        const c = t(u);\n        return c instanceof Promise ? c.then(o, s) : o(c);\n      } catch (c) {\n        s(c);\n      }\n    }, n);\n  }\n  /**\n   * @see Promise.resolve\n   */\n  static resolve(t) {\n    return new i((n) => {\n      n(t);\n    });\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new i((n, o) => {\n      o(t);\n    });\n  }\n  /**\n   * Cancels the promise execution.\n   */\n  cancel() {\n    this.reject(new d($));\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return T(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, n) {\n    return T(super.then(t, n), this);\n  }\n}\nfunction v(r, e) {\n  return r.resolve = e.resolve, r;\n}\nclass p extends i {\n  constructor(t, n) {\n    let o, s;\n    typeof t == \"function\" ? (o = t, s = n) : s = t;\n    let u;\n    super((c, a, h) => {\n      u = c, o && o(c, a, h);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    E(this, \"resolve\");\n    this.resolve = u;\n  }\n  /**\n   * Creates a new EnhancedPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn(t, n) {\n    return new p(\n      (o, s, u) => i.withFn(t, { abortSignal: u }).then(o, s),\n      n\n    );\n  }\n  /**\n   * @see Promise.resolve\n   */\n  static resolve(t) {\n    return new p((n) => {\n      n(t);\n    });\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new p((n, o) => {\n      o(t);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return v(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, n) {\n    return v(super.then(t, n), this);\n  }\n}\nfunction Z(r, e) {\n  return new i((t) => {\n    setTimeout(t, r);\n  }, { abortSignal: e });\n}\nfunction j(r) {\n  return `tapps/${r}`;\n}\nfunction J(r, e) {\n  sessionStorage.setItem(j(r), JSON.stringify(e));\n}\nfunction K(r) {\n  const e = sessionStorage.getItem(j(r));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction M(r) {\n  return r.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction z(r) {\n  return r.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction G(r) {\n  return r.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(r, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: o = !0\n  } = e;\n  function s(u, ...c) {\n    if (!o || typeof o == \"function\" && !o())\n      return;\n    const a = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n    console[u](\n      `%c${Intl.DateTimeFormat(\"en-GB\", {\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        second: \"2-digit\",\n        fractionalSecondDigits: 3,\n        timeZone: \"UTC\"\n      }).format(/* @__PURE__ */ new Date())}%c / %c${r}`,\n      `${a};background-color: lightblue;color:black`,\n      \"\",\n      `${a};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n      ...c\n    );\n  }\n  return [\n    function(...c) {\n      s(\"log\", ...c);\n    },\n    function(...c) {\n      s(\"error\", ...c);\n    }\n  ];\n}\nfunction H(r, e) {\n  document.documentElement.style.setProperty(r, e);\n}\nfunction P(r) {\n  document.documentElement.style.removeProperty(r);\n}\nexport {\n  i as CancelablePromise,\n  R as ERR_ABORTED,\n  $ as ERR_CANCELED,\n  S as ERR_TIMED_OUT,\n  p as EnhancedPromise,\n  d as TypedError,\n  x as addEventListener,\n  M as camelToKebab,\n  z as camelToSnake,\n  C as createAbortError,\n  _ as createCbCollector,\n  q as createLogger,\n  m as createTypedErrorPredicate,\n  P as deleteCssVar,\n  K as getStorageValue,\n  V as isAbortError,\n  B as isCanceledError,\n  F as isErrorOfType,\n  U as isTimeoutError,\n  H as setCssVar,\n  J as setStorageValue,\n  Z as sleep,\n  G as snakeToCamel\n};\n//# sourceMappingURL=index.js.map\n","export const ERR_AUTH_DATE_INVALID = 'ERR_AUTH_DATE_INVALID';\nexport const ERR_HASH_INVALID = 'ERR_HASH_INVALID';\nexport const ERR_EXPIRED = 'ERR_EXPIRED';\nexport const ERR_SIGN_INVALID = 'ERR_SIGN_INVALID';\n","import { TypedError } from '@telegram-apps/toolkit';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { initDataToSearchParams } from './initDataToSearchParams.js';\nimport type { SharedOptions, SignDataAsyncFn, SignDataSyncFn, Text } from './types.js';\nimport {\n  ERR_AUTH_DATE_INVALID,\n  ERR_EXPIRED,\n  ERR_HASH_INVALID,\n  ERR_SIGN_INVALID,\n} from './errors.js';\n\nexport interface ValidateOptions extends SharedOptions {\n  /**\n   * Time in seconds which states, how long from creation time init data is considered valid.\n   *\n   * In other words, in case when authDate + expiresIn is before current time, init data is\n   * recognized as expired.\n   *\n   * In case this value is equal to 0, the function does not check init data expiration.\n   * @default 86400 (1 day)\n   */\n  expiresIn?: number;\n}\n\nexport type ValidateValue = InitData | string | URLSearchParams;\n\nfunction processSign(actual: string, expected: string): void | never {\n  if (actual !== expected) {\n    throw new TypedError(ERR_SIGN_INVALID, 'Sign is invalid');\n  }\n  return;\n}\n\n/**\n * Validates passed init data.\n * @param value - value to check.\n * @param token - bot secret token.\n * @param signData - function signing data.\n * @param options - additional validation options.\n * @throws {Error} ERR_SIGN_INVALID\n * @throws {Error} ERR_AUTH_DATE_INVALID\n * @throws {Error} ERR_HASH_INVALID\n * @throws {Error} ERR_EXPIRED\n */\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataSyncFn,\n  options?: ValidateOptions,\n): void | never;\n\n/**\n * Validates passed init data.\n * @param value - value to check.\n * @param token - bot secret token.\n * @param signData - function signing data.\n * @param options - additional validation options.\n * @throws {Error} ERR_SIGN_INVALID\n * @throws {Error} ERR_AUTH_DATE_INVALID\n * @throws {Error} ERR_HASH_INVALID\n * @throws {Error} ERR_EXPIRED\n */\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataAsyncFn,\n  options?: ValidateOptions,\n): Promise<void>;\n\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataSyncFn | SignDataAsyncFn,\n  options: ValidateOptions = {},\n): void | never | Promise<void> {\n  // Init data required params.\n  let authDate: Date | undefined;\n  let hash: string | undefined;\n\n  // All search params pairs presented as `k=v`.\n  const pairs: string[] = [];\n\n  // Iterate over all key-value pairs of parsed parameters and find required\n  // parameters.\n  new URLSearchParams(\n    typeof value === 'string' || value instanceof URLSearchParams\n      ? value\n      : initDataToSearchParams(value),\n  ).forEach((value, key) => {\n    if (key === 'hash') {\n      hash = value;\n      return;\n    }\n\n    if (key === 'auth_date') {\n      const authDateNum = parseInt(value, 10);\n      if (!Number.isNaN(authDateNum)) {\n        authDate = new Date(authDateNum * 1000);\n      }\n    }\n\n    pairs.push(`${key}=${value}`);\n  });\n\n  // Hash and auth date always required.\n  if (!hash) {\n    throw new TypedError(ERR_HASH_INVALID, 'Hash is invalid');\n  }\n\n  if (!authDate) {\n    throw new TypedError(ERR_AUTH_DATE_INVALID, 'Auth date is invalid');\n  }\n\n  // In case, expiration time passed, we do additional parameters check.\n  const { expiresIn = 86400 } = options;\n  if (expiresIn > 0) {\n    // Check if init data expired.\n    if (+authDate + expiresIn * 1000 < Date.now()) {\n      throw new TypedError(ERR_EXPIRED, 'Init data is expired');\n    }\n  }\n\n  // According to docs, we sort all the pairs in alphabetical order.\n  pairs.sort();\n\n  const sign = signData(pairs.join('\\n'), token, options);\n\n  return typeof sign === 'string'\n    ? processSign(sign, hash)\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    : sign.then(v => processSign(v, hash!));\n}\n","import type { Text } from './types.js';\nimport type { ValidateOptions, ValidateValue } from './validate.js';\n\ntype ValidateSyncFn = (\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateOptions,\n) => void | never;\n\ntype ValidateAsyncFn = (\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateOptions,\n) => Promise<void>;\n\n/**\n * @param value - value to check.\n * @param token - bot secret token.\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is valid.\n */\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateSyncFn,\n  options?: ValidateOptions,\n): boolean;\n\n/**\n * @param value - value to check.\n * @param token - bot secret token.\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is valid.\n */\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateAsyncFn,\n  options?: ValidateOptions,\n): Promise<boolean>;\n\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateSyncFn | ValidateAsyncFn,\n  options?: ValidateOptions,\n): boolean | Promise<boolean> {\n  try {\n    const maybePromise = validate(value, token, options);\n    return maybePromise\n      ? maybePromise.then(() => true, () => false)\n      : true;\n  } catch {\n    return false;\n  }\n}\n","class i extends Error {\n  constructor(e, r, a) {\n    super(\n      typeof r == \"object\" ? r.message : r || e,\n      {\n        cause: typeof r == \"object\" ? r.cause : a\n      }\n    ), this.type = e, Object.setPrototypeOf(this, i.prototype);\n  }\n}\nfunction b(t) {\n  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction E(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nconst R = \"ERR_INVALID_VALUE\", S = \"ERR_UNEXPECTED_VALUE\", w = \"ERR_UNEXPECTED_TYPE\", h = \"ERR_PARSE\";\nfunction y(t, e) {\n  const r = {};\n  for (const a in t) {\n    const n = t[a];\n    if (!n)\n      continue;\n    let o, c;\n    typeof n == \"function\" ? (o = a, c = n) : [o, c] = n;\n    try {\n      const p = c(e(o));\n      p !== void 0 && (r[a] = p);\n    } catch (p) {\n      throw new i(\n        h,\n        `Parser for \"${a}\" property failed${o === a ? \"\" : `. Source field: \"${o}\"`}`,\n        p\n      );\n    }\n  }\n  return r;\n}\nfunction d(t) {\n  let e = t;\n  if (typeof e == \"string\")\n    try {\n      e = JSON.parse(e);\n    } catch (r) {\n      throw new i(R, { cause: r });\n    }\n  if (typeof e != \"object\" || !e || Array.isArray(e))\n    throw new i(S);\n  return e;\n}\nfunction s(t, e) {\n  return (r) => {\n    const a = (n) => {\n      if (!(r && n === void 0))\n        try {\n          return e(n);\n        } catch (o) {\n          throw new i(h, {\n            message: `\"${t}\" transformer failed to parse the value`,\n            cause: o\n          });\n        }\n    };\n    return /* @__PURE__ */ Object.assign(\n      a,\n      {\n        isValid(n) {\n          try {\n            return a(n), !0;\n          } catch {\n            return !1;\n          }\n        }\n      }\n    );\n  };\n}\nfunction l(t, e) {\n  return s(e || \"object\", (r) => {\n    const a = d(r);\n    return y(t, (n) => a[n]);\n  });\n}\nfunction f(t) {\n  throw new i(w, `Unexpected value received: ${JSON.stringify(t)}`);\n}\nconst A = s(\"boolean\", (t) => {\n  if (typeof t == \"boolean\")\n    return t;\n  const e = String(t);\n  if (e === \"1\" || e === \"true\")\n    return !0;\n  if (e === \"0\" || e === \"false\")\n    return !1;\n  f(t);\n}), u = s(\"string\", (t) => {\n  if (typeof t == \"string\" || typeof t == \"number\")\n    return t.toString();\n  f(t);\n}), g = s(\"number\", (t) => {\n  if (typeof t == \"number\")\n    return t;\n  if (typeof t == \"string\") {\n    const e = Number(t);\n    if (!Number.isNaN(e))\n      return e;\n  }\n  f(t);\n}), D = s(\"date\", (t) => t instanceof Date ? t : new Date(g()(t) * 1e3));\nfunction P(t, e) {\n  return s(e || \"searchParams\", (r) => {\n    typeof r != \"string\" && !(r instanceof URLSearchParams) && f(r);\n    const a = typeof r == \"string\" ? new URLSearchParams(r) : r;\n    return y(t, (n) => {\n      const o = a.get(n);\n      return o === null ? void 0 : o;\n    });\n  });\n}\nfunction m(t) {\n  for (const e in t)\n    t[e] = [b(e), t[e]];\n  return t;\n}\nconst U = (t) => {\n  const e = g(), r = g(!0), a = u(), n = u(!0), o = A(!0), c = l(m({\n    addedToAttachmentMenu: o,\n    allowsWriteToPm: o,\n    firstName: a,\n    id: e,\n    isBot: o,\n    isPremium: o,\n    languageCode: n,\n    lastName: n,\n    photoUrl: n,\n    username: n\n  }), \"User\")(!0);\n  return P(\n    m({\n      authDate: D(),\n      canSendAfter: r,\n      chat: l(\n        m({\n          id: e,\n          type: a,\n          title: a,\n          photoUrl: n,\n          username: n\n        }),\n        \"Chat\"\n      )(!0),\n      chatInstance: n,\n      chatType: n,\n      hash: a,\n      queryId: n,\n      receiver: c,\n      startParam: n,\n      user: c\n    }),\n    \"initData\"\n  )(t);\n};\nfunction N(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nfunction O(t) {\n  return /^#[\\da-f]{3}$/i.test(t);\n}\nfunction W(t) {\n  const e = t.replace(/\\s/g, \"\").toLowerCase();\n  if (N(e))\n    return e;\n  if (O(e)) {\n    let a = \"#\";\n    for (let n = 0; n < 3; n += 1)\n      a += e[1 + n].repeat(2);\n    return a;\n  }\n  const r = e.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || e.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${t}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((a, n) => {\n    const o = parseInt(n, 10).toString(16);\n    return a + (o.length === 1 ? \"0\" : \"\") + o;\n  }, \"#\");\n}\nconst _ = s(\"rgb\", (t) => W(u()(t))), T = s(\n  \"themeParams\",\n  (t) => {\n    const e = _(!0);\n    return Object.entries(d(t)).reduce((r, [a, n]) => (r[E(a)] = e(n), r), {});\n  }\n);\n// @__NO_SIDE_EFFECTS__\nfunction V(t) {\n  return JSON.stringify(\n    Object.fromEntries(\n      Object.entries(t).map(([e, r]) => [b(e), r])\n    )\n  );\n}\nconst $ = (t) => {\n  const e = u(), r = u(!0), a = A(!0);\n  return P({\n    botInline: [\"tgWebAppBotInline\", a],\n    initData: [\"tgWebAppData\", U(!0)],\n    initDataRaw: [\"tgWebAppData\", r],\n    platform: [\"tgWebAppPlatform\", e],\n    showSettings: [\"tgWebAppShowSettings\", a],\n    startParam: [\"tgWebAppStartParam\", r],\n    themeParams: [\"tgWebAppThemeParams\", T()],\n    version: [\"tgWebAppVersion\", e]\n  }, \"launchParams\")(t);\n};\n// @__NO_SIDE_EFFECTS__\nfunction j(t) {\n  const { initDataRaw: e, startParam: r, showSettings: a, botInline: n } = t, o = new URLSearchParams();\n  return o.set(\"tgWebAppPlatform\", t.platform), o.set(\"tgWebAppThemeParams\", /* @__PURE__ */ V(t.themeParams)), o.set(\"tgWebAppVersion\", t.version), e && o.set(\"tgWebAppData\", e), r && o.set(\"tgWebAppStartParam\", r), typeof a == \"boolean\" && o.set(\"tgWebAppShowSettings\", a ? \"1\" : \"0\"), typeof n == \"boolean\" && o.set(\"tgWebAppBotInline\", n ? \"1\" : \"0\"), o.toString();\n}\nconst L = l({\n  eventType: u(),\n  eventData: (t) => t\n}, \"miniAppsMessage\");\nfunction I(t, e) {\n  return s(e || \"array\", (r) => {\n    let a;\n    if (Array.isArray(r))\n      a = r;\n    else if (typeof r == \"string\")\n      try {\n        const n = JSON.parse(r);\n        Array.isArray(n) && (a = n);\n      } catch {\n      }\n    return a || f(r), a.map(t);\n  });\n}\nconst C = s(\"fn\", (t) => {\n  if (typeof t == \"function\")\n    return t;\n  f(t);\n});\nfunction B(t) {\n  return !!t && typeof t == \"object\" && !Array.isArray(t);\n}\nexport {\n  R as ERR_INVALID_VALUE,\n  h as ERR_PARSE,\n  w as ERR_UNEXPECTED_TYPE,\n  S as ERR_UNEXPECTED_VALUE,\n  I as array,\n  A as boolean,\n  s as createTransformerGen,\n  D as date,\n  C as fn,\n  U as initData,\n  N as isRGB,\n  O as isRGBShort,\n  B as isRecord,\n  $ as launchParams,\n  L as miniAppsMessage,\n  g as number,\n  l as object,\n  _ as rgb,\n  P as searchParams,\n  j as serializeLaunchParams,\n  V as serializeThemeParams,\n  u as string,\n  T as themeParams,\n  W as toRGB,\n  d as toRecord\n};\n//# sourceMappingURL=index.js.map\n","import { initData } from '@telegram-apps/transformers';\nimport type { InitData } from '@telegram-apps/types';\n\n/**\n * Parses incoming value as init data.\n * @param value - value to check.\n * @throws {TypedError} ERR_PARSE\n * @throws {TypedError} ERR_UNEXPECTED_VALUE\n */\nexport function parse(value: unknown): InitData {\n  return initData()(value);\n}"],"names":["signData","processSign","s","sign","d","TypedError","value","validate","initData"],"mappings":"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"}