"use strict";
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
function removeUndefined(object) {
  const result = {};
  for (const key in object) {
    const v = object[key];
    if (v !== void 0) {
      result[key] = v;
    }
  }
  return result;
}
function serializeUser(user) {
  return user ? JSON.stringify({
    added_to_attachment_menu: user.addedToAttachmentMenu,
    allows_write_to_pm: user.allowsWriteToPm,
    first_name: user.firstName,
    id: user.id,
    is_bot: user.isBot,
    is_premium: user.isPremium,
    language_code: user.languageCode,
    last_name: user.lastName,
    photo_url: user.photoUrl,
    username: user.username
  }) : void 0;
}
function initDataToSearchParams({
  chat,
  receiver,
  user,
  ...data
}) {
  var _a;
  return new URLSearchParams(
    removeUndefined({
      auth_date: data.authDate ? (+data.authDate / 1e3 | 0).toString() : void 0,
      can_send_after: (_a = data.canSendAfter) == null ? void 0 : _a.toString(),
      chat: chat ? JSON.stringify({
        id: chat.id,
        type: chat.type,
        title: chat.title,
        photo_url: chat.type,
        username: chat.username
      }) : void 0,
      chat_instance: data.chatInstance,
      chat_type: data.chatType || void 0,
      hash: data.hash,
      query_id: data.queryId,
      receiver: serializeUser(receiver),
      start_param: data.startParam || void 0,
      user: serializeUser(user)
    })
  );
}
function sign(data, key, authDate, signData2, options) {
  const sp = initDataToSearchParams({
    ...data,
    authDate
  });
  const pairs = [...sp.entries()].map(([name, value]) => `${name}=${value}`).sort();
  function processSign2(s2) {
    sp.append("hash", s2);
    return sp.toString();
  }
  const sign2 = signData2(pairs.join("\n"), key, options);
  return typeof sign2 === "string" ? processSign2(sign2) : sign2.then(processSign2);
}
function signData(data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? key : hashToken(key, createHmac);
  if (keyHmac instanceof Promise) {
    return keyHmac.then((v) => createHmac(data, v)).then((v) => v.toString("hex"));
  }
  const hmac = createHmac(data, typeof keyHmac === "string" ? Buffer.from(keyHmac, "hex") : keyHmac);
  return hmac instanceof Promise ? hmac.then((v) => v.toString("hex")) : hmac.toString("hex");
}
let d$1 = class d extends Error {
  constructor(e, t, n) {
    super(
      typeof t == "object" ? t.message : t || e,
      {
        cause: typeof t == "object" ? t.cause : n
      }
    ), this.type = e, Object.setPrototypeOf(this, d.prototype);
  }
};
function F(r, e) {
  return r instanceof d$1 && r.type === e;
}
const ERR_AUTH_DATE_INVALID = "ERR_AUTH_DATE_INVALID";
const ERR_HASH_INVALID = "ERR_HASH_INVALID";
const ERR_EXPIRED = "ERR_EXPIRED";
const ERR_SIGN_INVALID = "ERR_SIGN_INVALID";
function processSign(actual, expected) {
  if (actual !== expected) {
    throw new d$1(ERR_SIGN_INVALID, "Sign is invalid");
  }
  return;
}
function validate(value, token, signData2, options = {}) {
  let authDate;
  let hash;
  const pairs = [];
  new URLSearchParams(
    typeof value === "string" || value instanceof URLSearchParams ? value : initDataToSearchParams(value)
  ).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    throw new d$1(ERR_HASH_INVALID, "Hash is invalid");
  }
  if (!authDate) {
    throw new d$1(ERR_AUTH_DATE_INVALID, "Auth date is invalid");
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    if (+authDate + expiresIn * 1e3 < Date.now()) {
      throw new d$1(ERR_EXPIRED, "Init data is expired");
    }
  }
  pairs.sort();
  const sign2 = signData2(pairs.join("\n"), token, options);
  return typeof sign2 === "string" ? processSign(sign2, hash) : sign2.then((v) => processSign(v, hash));
}
function isValid(value, token, validate2, options) {
  try {
    const maybePromise = validate2(value, token, options);
    return maybePromise ? maybePromise.then(() => true, () => false) : true;
  } catch {
    return false;
  }
}
class i extends Error {
  constructor(e, r, a) {
    super(
      typeof r == "object" ? r.message : r || e,
      {
        cause: typeof r == "object" ? r.cause : a
      }
    ), this.type = e, Object.setPrototypeOf(this, i.prototype);
  }
}
function b(t) {
  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);
}
const R = "ERR_INVALID_VALUE", S = "ERR_UNEXPECTED_VALUE", w = "ERR_UNEXPECTED_TYPE", h = "ERR_PARSE";
function y(t, e) {
  const r = {};
  for (const a in t) {
    const n = t[a];
    if (!n)
      continue;
    let o, c;
    typeof n == "function" ? (o = a, c = n) : [o, c] = n;
    try {
      const p = c(e(o));
      p !== void 0 && (r[a] = p);
    } catch (p) {
      throw new i(
        h,
        `Parser for "${a}" property failed${o === a ? "" : `. Source field: "${o}"`}`,
        p
      );
    }
  }
  return r;
}
function d2(t) {
  let e = t;
  if (typeof e == "string")
    try {
      e = JSON.parse(e);
    } catch (r) {
      throw new i(R, { cause: r });
    }
  if (typeof e != "object" || !e || Array.isArray(e))
    throw new i(S);
  return e;
}
function s(t, e) {
  return (r) => {
    const a = (n) => {
      if (!(r && n === void 0))
        try {
          return e(n);
        } catch (o) {
          throw new i(h, {
            message: `"${t}" transformer failed to parse the value`,
            cause: o
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      a,
      {
        isValid(n) {
          try {
            return a(n), true;
          } catch {
            return false;
          }
        }
      }
    );
  };
}
function l(t, e) {
  return s(e || "object", (r) => {
    const a = d2(r);
    return y(t, (n) => a[n]);
  });
}
function f(t) {
  throw new i(w, `Unexpected value received: ${JSON.stringify(t)}`);
}
const A = s("boolean", (t) => {
  if (typeof t == "boolean")
    return t;
  const e = String(t);
  if (e === "1" || e === "true")
    return true;
  if (e === "0" || e === "false")
    return false;
  f(t);
}), u = s("string", (t) => {
  if (typeof t == "string" || typeof t == "number")
    return t.toString();
  f(t);
}), g = s("number", (t) => {
  if (typeof t == "number")
    return t;
  if (typeof t == "string") {
    const e = Number(t);
    if (!Number.isNaN(e))
      return e;
  }
  f(t);
}), D = s("date", (t) => t instanceof Date ? t : new Date(g()(t) * 1e3));
function P(t, e) {
  return s(e, (r) => {
    typeof r != "string" && !(r instanceof URLSearchParams) && f(r);
    const a = typeof r == "string" ? new URLSearchParams(r) : r;
    return y(t, (n) => {
      const o = a.get(n);
      return o === null ? void 0 : o;
    });
  });
}
function m(t) {
  for (const e in t)
    t[e] = [b(e), t[e]];
  return t;
}
const U = (t) => {
  const e = g(), r = g(true), a = u(), n = u(true), o = A(true), c = l(m({
    addedToAttachmentMenu: o,
    allowsWriteToPm: o,
    firstName: a,
    id: e,
    isBot: o,
    isPremium: o,
    languageCode: n,
    lastName: n,
    photoUrl: n,
    username: n
  }), "User")(true);
  return P(
    m({
      authDate: D(),
      canSendAfter: r,
      chat: l(
        m({
          id: e,
          type: a,
          title: a,
          photoUrl: n,
          username: n
        }),
        "Chat"
      )(true),
      chatInstance: n,
      chatType: n,
      hash: a,
      queryId: n,
      receiver: c,
      startParam: n,
      user: c
    }),
    "initData"
  )(t);
};
function parse(value) {
  return U()(value);
}
exports.ERR_AUTH_DATE_INVALID = ERR_AUTH_DATE_INVALID;
exports.ERR_EXPIRED = ERR_EXPIRED;
exports.ERR_HASH_INVALID = ERR_HASH_INVALID;
exports.ERR_SIGN_INVALID = ERR_SIGN_INVALID;
exports.F = F;
exports.S = S;
exports.d = d$1;
exports.h = h;
exports.hashToken = hashToken;
exports.initDataToSearchParams = initDataToSearchParams;
exports.isValid = isValid;
exports.parse = parse;
exports.sign = sign;
exports.signData = signData;
exports.validate = validate;
//# sourceMappingURL=parse-BsMfaAL1.cjs.map
